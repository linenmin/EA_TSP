# r0927480.py 算法策略详情文档

**文件源**: `r0927480.py`
**算法架构**: 混合遗传算法 (HGA) + 并行侦察者 (Scout Process) + 引导局部搜索 (GLS)
**核心目标**: 解决旅行商问题 (TSP)，在非对称 (ATSP) 和对称 (TSP) 实例上均能表现出色。

---

## 1. 系统与环境配置 (System Environment)

为了在高性能计算 (HPC) 环境或多核机器上保证资源分配的确定性和防止过度订阅 (Oversubscription)，代码强制设置了严格的线程控制。

- **环境变量设置**:
  - `OPENBLAS_NUM_THREADS = "1"`
  - `MKL_NUM_THREADS = "1"`
  - `OMP_NUM_THREADS = "1"`
  - `NUMBA_NUM_THREADS = "1"`
  - **目的**: 强制所有底层数学库和 JIT 编译器在每个进程中只使用一个线程。因为算法采用多进程（Main + Scout）架构，这能避免 CPU 竞争，提高缓存命中率。

---

## 2. 核心超参数 (Hyperparameters)

算法根据问题规模 $N$ (城市数量) 动态调整超参数。

### 2.1 主进程 (Main Solver) 参数

| 参数项                | N < 300 | 300 ≤ N < 600 | 600 ≤ N < 850 | N ≥ 850 | 描述                                                                     |
| :-------------------- | :------ | :------------ | :------------ | :------ | :----------------------------------------------------------------------- |
| **种群大小 (lam)**    | 1000    | 150           | 100           | 100     | 较小规模问题使用大种群以避免早熟；大规模问题减小种群以提高代数迭代速度。 |
| **停滞阈值 (Limit)**  | 500     | 150           | 200           | 150     | 超过此代数未改进全局最优，触发重置 (Apocalypse)。                        |
| **变异率 (mut)**      | 30%     | 15%           | 10%           | 10%     | 控制子代进行变异操作的概率。                                             |
| **局部搜索强度 (ls)** | 30      | 30            | 10            | 10      | 精英个体进行 VND 搜索时的最大迭代次数/步长。                             |

### 2.2 侦察者进程 (Scout Worker) 参数

*   **KNN 邻居数**: 32
*   **Ruin Gears (破坏强度档位)**: `[0.03, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45]`
    *   **动态调整机制**: 每 250 次迭代，破坏强度档位 +1（循环取模）。
*   **通信门槛**:
    *   **Breakthrough**: 如果侦察到的解优于它接收到的初始解，立即发送。
    *   **Tolerance**: 如果停滞 > 500 次，容忍度设为 0.3%；停滞 > 2000 次，容忍度设为 0.8%。允许稍微差一点但具有潜力的解回传。
    *   **发送冷却**: 非突破性解至少间隔 200 次迭代才发送。

---

## 3. 算法核心组件详情 (Component Details)

### 3.1 初始化策略 (Initialization)

种群初始化采用混合策略，以平衡随机性和初始质量：
*   **策略分布**:
    1.  **RCL-NN (10%)**: 受限候选列表最近邻。每次从最近的 $r$ 个邻居中随机选择一个。$r \in [3, 11)$。
    2.  **Insertion (30%)**: 插入法。随机选择是“最远插入”还是“随机插入”。
    3.  **Random + Repair (60%)**: 完全随机排列，随后尝试最多 50 次 2-opt 修复以确保可行性（针对 ATSP）。
*   **可行性保障**: 如果生成的路径不可行（含无穷大边），强制回退到安全的 RCL-NN 方法。

### 3.2 遗传算子 (Genetic Operators)

*   **选择 (Selection)**: 锦标赛选择 (Tournament Size = 5)，每次选出两个父代 P1, P2。
*   **交叉 (Crossover)**:
    *   **OX (Order Crossover)**: 采用 `_ox_jit_inplace`。保留 P1 的一个片段，剩余城市按 P2 的顺序填入。生成两个子代 C1, C2。
*   **变异 (Mutation)**:
    *   **触发**: 基于 `exploit_mut` 概率。
    *   **对称实例 (Symmetric)**: 30% 概率做 **Scramble** (区间乱序)，70% 概率做 **Inversion** (区间翻转/2-opt move)。
    *   **非对称实例 (Asymmetric)**: 只能做 **Extraction-Reinsertion** (类似于 Or-opt 的移动单点)，因为翻转会导致边方向改变从而不可行。
*   **修复 (Repair)**:
    *   变异后必须检查可行性。如果不可行，对称实例尝试用 `_repair_jit` (有限次 2-opt) 修复；不可修复则**回滚**到父代。

### 3.3 局部搜索 (Local Search: VND)

主进程对精英个体（前 20%）应用变邻域下降 (VND) 搜索，包含两种算子：
1.  **Or-opt (Relocate)**: 移动连续的 $k$ 个城市的一段到新位置 (Block Size = 1, 2, 3)。
2.  **Block Swap**: 交换两个不相邻的块 (Block Size = 2)。
*   **优化**: 使用 `dlb_mask` (Don't Look Bits) 忽略未改变的区域，加速搜索。使用预分配的 `pos_buffer` 和 `tour_buffer` 实现零内存使用。

### 3.4 多样性维持 (Diversity: RTR)

*   **RTR (Record-to-Record) Challenge**:
    *   子代不直接替换父代，而是与整个种群的一个随机子窗（Window size = $\min(50, \text{lam})$）中的个体进行比较。
    *   找到与子代结构最相似（Bond Distance 最小）的个体。
    *   **替换规则**: 如果子代比该最相似个体更好，或者在非常相似（距离 < 15% N）的情况下子代不比它差太多（< 5% 差距），则替换之。

### 3.5 侦察者机制 (Scout / Trauma Center)

这是一个独立的并行进程，专门用于将主进程陷入局部最优的“病人”解进行深度手术。
*   **核心算法**: 仅使用 **Hybrid Ruin & Recreate (LNS)**，不使用遗传算法。
*   **混合破坏策略 (Hybrid Ruin)**:
    1.  **BFS Ruin (70%)**: 以某点为中心，移除其空间上的 $k$ 个近邻。
    2.  **Worst Edge Ruin (20%)**: 锦标赛选择，优先移除图中长度最长的边。
    3.  **Sequence Ruin (10%)**: 移除连续的一段路径。
*   **重建策略**: 贪婪插入 (Cheapest Insertion)，支持 Regret (但代码主要使用标准插入)。
*   **后处理**: 重建后立即运行 `Or-opt` 和 `Block Swap` 进行抛光。

### 3.6 引导局部搜索 (GLS - Guided Local Search)

*   **触发**: 当停滞计数器 $\ge \max(30, 0.6 \times \text{Limit})$ 时激活。
*   **更新频率**: 每 50 代更新一次惩罚矩阵。
*   **惩罚逻辑**:
    *   计算效用 $Utility(u, v) = \frac{D_{uv}}{1 + penalty_{uv}}$。
    *   找出当前最优路径中效用最大的边，将其 $penalty_{uv}$ 加 1。
    *   **修正距离矩阵**: $D_{GLS} = D + \lambda \times \frac{BestCost}{N} \times Penalty$，其中 $\lambda = 0.03$。

---

## 4. 整体执行流程 (Workflow)

1.  **启动**: 初始化主进程和 Scout 进程，建立双向通信队列。
2.  **初始种群**: 生成 `lam` 个个体，计算适应度，初始化全局最优。
3.  **主循环 (While True)**:
    *   **Scout 通信**: 检查 `q_from_scout`。若有更好的解，直接替换种群中最差个体，并可能更新全局最优。
    *   **进化 (Evolve)**: 进行选择、交叉、变异。
    *   **精英优化**: 对前 20% 子代进行 VND 局部搜索。
    *   **RTR 替换**: 将优化后的子代通过 RTR 机制尝试并入种群。
    *   **停滞判定**:
        *   若本轮最优值未改进，停滞计数 `stagnation_counter` +1。
        *   若改进，重置计数。
    *   **GLS 管理**: 满足条件时，激活并更新 GLS 惩罚矩阵。
    *   **发送病人**: 停滞过半且冷却时间满足时，将当前最优解发送给 Scout。
    *   **大重置 (Apocalypse)**:
        *   当 `stagnation_counter >= limit`：
            1.  清空 Scout 队列。
            2.  清空 GLS 惩罚。
            3.  **70% 重生**: 70% 个体完全重新初始化（使用更大的 RCL 随机性 $r \in [15, 40)$）。
            4.  **30% 继承**: 30% 个体基于历史最优解 (`best_tour_ever`) 进行 1-3 次双桥 (Double Bridge) 扰动生成。
            5.  Scout 同步到新的搜索区域。
4.  **终止**: 用户中断或外部时间限制。

---

## 5. 关键代码细节与优化

*   **In-place Operations**: 绝大多数 JIT 函数（如 `_ox_jit_inplace`, `_optimization`）都设计为原地修改数组，避免 Python 的垃圾回收开销。
*   **Zero-Allocation**: 在循环内部（尤其是 Scout 和 VND 中），使用了预先分配的 `pos_buffer` 和 `tour_buffer`，使得成千上万次的迭代中没有 `np.empty` 或 `np.zeros` 调用，极大提升了速度。
*   **Safety Checks**: 在每一步关键操作（初始化、变异、修复）后，都有 `_tour_feasible_jit` 检查，确保在处理 ATSP（包含 `inf` 距离）时不会产生非法解。
