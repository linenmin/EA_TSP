# TSP Memetic Algorithm 技术文档

## 概述

本项目实现了一个**Memetic Algorithm (MA)** 求解旅行商问题 (TSP)。Memetic Algorithm 是遗传算法 (GA) 与局部搜索 (LS) 的结合体，利用 GA 的全局探索能力和 LS 的局部优化能力来高效求解组合优化问题。

### 核心文件

| 文件 | 功能 |
|------|------|
| `optimized_thread_LocalSearch_inf.py` | 核心求解器，包含所有算法组件 |
| `run_island_model.py` | 并行岛屿模型启动器，管理多进程通信 |

---

## 算法架构总览

```
┌─────────────────────────────────────────────────────────────────┐
│                         Island Model                            │
│  ┌─────────────────────┐       ┌─────────────────────┐          │
│  │   Island 0          │       │   Island 1          │          │
│  │   (Exploiter)       │◄─────►│   (Explorer)        │          │
│  │   高选择压力         │  移民  │   低选择压力         │          │
│  │   低变异率           │       │   高变异率           │          │
│  └─────────────────────┘       └─────────────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Evolution Loop (每代)                         │
│                                                                  │
│  1. Tournament Selection (亲本选择)                              │
│  2. OX Crossover (交叉)                                          │
│  3. Hybrid Mutation (变异)                                       │
│  4. Repair (修复不可行解)                                        │
│  5. Batch Evaluation (适应度评估)                                │
│  6. Elite-Only Candidate Or-Opt (精英局部搜索)                   │
│  7. RTR Replacement (受限锦标赛替换)                             │
│  8. Migration & Repulsion (移民与排斥)                           │
│  9. Stagnation Restart (停滞重启)                                │
│  10. Final Polish (Double Bridge + 2-Opt)                       │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1. 交叉算子 (Crossover)

### 当前使用: Order Crossover (OX)

**函数**: `_ox_jit(p1, p2)` (lines 118-149)

**工作原理**:
1. 随机选择两个切点 `[cut1, cut2)`
2. 将父代1在切点间的片段**原封不动**复制到子代
3. 从切点2开始，按父代2的顺序填充剩余城市

**代码片段**:
```python
cut1 = np.random.randint(0, n - 1)
cut2 = np.random.randint(cut1 + 1, n)
for i in range(cut1, cut2):
    child[i] = p1[i]  # 保留 p1 的子路径
# 按 p2 顺序填充其余
```

### 为什么选择 OX 而非 ERX?

| 特性 | OX | ERX |
|------|-----|-----|
| 保留结构 | **连续子路径** | 边 (Edge) |
| 与 Or-Opt 配合 | ⭐ 完美 | ❌ 差 |
| 代码复杂度 | 34 行 | 77 行 |
| 收敛速度 | ⭐ 快 | 慢 |

**关键洞察**: 
- ERX 保留"边"，会打碎已经被局部搜索优化好的连续子路径。
- OX 保留"子路径"，与 Or-Opt 形成完美互补：OX 负责宏观组合，Or-Opt 负责微观调整。

### 其他未采用的交叉算子

| 算子 | 未采用原因 |
|------|-----------|
| **PMX** | 与 OX 类似但更复杂，对 TSP 无额外优势 |
| **Cycle Crossover** | 保留位置而非子路径，不适合 TSP |
| **EAX** | 最强但实现极复杂，需 AB-cycle 分解 |

---

## 2. 变异算子 (Mutation)

### 当前使用: Hybrid Mutation

**函数**: `_hybrid_mutation_inplace(tour)` (未直接显示，在 r0123456 类中)

**策略**:
- 70% 概率: **Inversion (反转变异)** — 随机选择一段，反转其顺序
- 30% 概率: **Insertion (插入变异)** — 将一个城市移动到另一个位置

### 为什么选择这个组合?

- **Inversion**: 大扰动，改变路径的"宏观形状"，帮助逃离局部最优。
- **Insertion**: 小扰动，微调城市位置，与 Or-Opt 类似但更轻量。

### 未采用的变异算子

| 算子 | 未采用原因 |
|------|-----------|
| **Swap** | 太弱，同时破坏两处结构 |
| **Scramble** | 太激进，破坏已优化结构 |

---

## 3. 局部搜索 (Local Search)

### 当前使用: Candidate-List Driven Or-Opt

**函数**: `_candidate_or_opt_jit(tour, D, knn_idx, max_iters)` (lines 391-484)

**核心创新 (P1)**:
- 使用预计算的 **KNN 索引** (K=32) 驱动搜索
- 只尝试将城市移动到其 K 个最近邻附近
- 避免随机采样的"盲人摸象"问题

**代码片段**:
```python
for k in range(K):
    target = knn_idx[u, k]  # 只考虑 K 个最近邻
    # 尝试将 u 插入到 target 后面
    delta = (new_edge_cost - remove_cost) + (insert_cost - old_edge_cost)
    if delta < -1e-6:  # 找到改进
        # 执行移动
```

### 为什么选择 Or-Opt 而非 2-Opt?

**关键发现**: 您的 TSP 实例是**非对称的** (`D[i,j] ≠ D[j,i]`)!

| 算子 | 对称 TSP | 非对称 TSP |
|------|----------|------------|
| **2-Opt** | ✅ 正确 | ❌ Delta 计算错误 |
| **Or-Opt** | ✅ 正确 | ✅ 正确 |

**原因**: 2-Opt 反转一段路径，会改变内部所有边的方向。在非对称 TSP 中，`D[A,B] ≠ D[B,A]`，所以反转后的路径长度不能用简单的 Delta 公式计算。

Or-Opt (块移动) 只改变**切点处的 3 条边**，不改变内部边的方向，因此在非对称 TSP 上是正确的。

### 为什么使用 KNN 候选列表?

**问题**: 随机采样的 2-Opt/Or-Opt 只能覆盖 ~0.4% 的候选对，效率极低。

**解决**: 使用 KNN 候选列表将搜索聚焦到最可能产生改进的邻域。

| 方法 | 每次尝试数 | 找到改进概率 |
|------|-----------|-------------|
| 随机采样 | ~2000 随机 | 低 (盲目) |
| **KNN 候选列表** | n × K 有序 | 高 (有目标) |

### 精英优先策略 (P3)

**改动**: 只对适应度前 20% 的子代进行局部搜索。

**原因**:
1. **防止同质化**: 如果对所有子代都做 LS，会把整个种群拉到同一个局部最优。
2. **节省时间**: LS 是最耗时的操作，只对精英做可以跑更多代数。
3. **保留多样性**: 未经 LS 的子代保留了交叉/变异产生的结构差异。

---

## 4. 选择与替换机制

### 亲本选择: Tournament Selection

**函数**: `_k_tournament_idx(fitness, k)` (lines 1076-1081)

**参数**:
- **Exploiter (Island 0)**: k=5 (高压力)
- **Explorer (Island 1)**: k=2 (低压力)

### 替换机制: RTR (Restricted Tournament Replacement)

**函数**: `rtr_challenge_jit(child, child_fit, pop, fit, W, rng_seed)` (lines 707-740)

**工作原理**:
1. 随机选择 W=20 个个体作为"窗口"
2. 在窗口中找到与子代**最相似**的个体 (Bond Distance 最小)
3. 如果子代更优，则替换该个体

**为什么选择 RTR?**

| 替换策略 | 多样性保持 | 选择压力 |
|----------|-----------|----------|
| Generational | ❌ 差 | 高 |
| Elitism | ❌ 较差 | 极高 |
| **RTR** | ⭐ 优秀 | 中等 |

RTR 强制子代与"相似"的个体竞争，这意味着在搜索空间的不同区域可以同时存在多个"优秀家族"，避免过早收敛。

### 未采用的替换策略

| 策略 | 未采用原因 |
|------|-----------|
| **Deterministic Crowding** | RTR 是其增强版 |
| **(μ+λ)** | 没有多样性保护机制 |
| **Fitness Sharing** | 计算开销大 |

---

## 5. 岛屿模型 (Hierarchical Selection Migration)

### 架构演进

经过多轮诊断分析，迁移策略从"注射式"进一步优化为**分层筛选迁移 (Hierarchical Selection)**。

#### V1: 传统双向迁移 (已弃用)
- 问题: Explorer 被 Exploiter "同化"，失去多样性

#### V2: 注射式岛屿 (中间版本)
- 问题: Explorer 只在发现改进时发送，时机不稳定；发送后立即重启，丢失积累

#### V3: 分层筛选迁移 (当前版本)
```
每 50 代:

Explorer:
  1. 接收 Exploiter 最优解 (用于距离计算)
  2. 筛选前 30% 适应度 (质量门槛)
  3. 选距离最大的 2% 个体 (多样性优先)
  4. 对每个做 20 步 Or-Opt (发送前优化)
  5. 发送给 Exploiter
  6. 继续进化 (不重启)

Exploiter:
  1. 发送最优解给 Explorer (用于距离计算)
  2. 接收 Explorer 的多样性注射
  3. 用 RTR 融合
```

### 发送策略详解

| 环节 | 配置 | 说明 |
|------|------|------|
| **发送内容** | 分层筛选 | 前 30% 适应度 → 选距离最大的 |
| **发送数量** | 2% 种群 | `max(1, int(λ * 0.02))` |
| **发送时机** | 每 50 代 | 定期发送，不依赖改进检测 |
| **发送前优化** | 20 步 Or-Opt | 提升质量，增加被 RTR 接受概率 |
| **接收策略** | RTR | 窗口 W=20，与相似个体竞争 |
| **发送后行为** | 继续进化 | 不重启，保留积累 |

### 为什么使用分层筛选?

**核心洞察**: Exploiter 已经知道最优解长什么样了，它需要的是"不一样的结构"。

```python
# 分层筛选逻辑
# Step 1: 质量门槛 - 筛选前 30%
quality_elite = sorted_indices[:int(λ * 0.3)]

# Step 2: 多样性优先 - 选距离最大的
distances = [bond_distance(individual, exploiter_best) for individual in quality_elite]
selected = quality_elite[argsort(distances)[::-1][:send_count]]

# Step 3: 发送前优化 - 20 步 Or-Opt
for idx in selected:
    _candidate_or_opt_jit(migrant, D, knn_idx, max_iters=20)
```

### 角色分工

| 角色 | Exploiter (Island 0) | Explorer (Island 1) |
|------|---------------------|---------------------|
| **使命** | 深度优化当前最佳区域 | 探索新区域，发送多样性 |
| **选择压力** | k=5 (高) | k=2 (低) |
| **变异率** | 0.3-0.4 | 0.6-0.8 |
| **精英 LS** | 20% 精英, 完整步数 | 10% 精英, 5 步 |
| **发送** | 最优解 (用于距离计算) | 分层筛选的多样性精英 |
| **接收** | RTR 融合 | 仅存储用于距离计算 |

### 设计决策

| 决策 | 原因 |
|------|------|
| **定期发送** | 不依赖改进检测，稳定注入多样性 |
| **质量门槛 30%** | 过滤掉太差的解，确保被 RTR 接受 |
| **距离最大化** | 解决"发送重复解"的问题 |
| **发送前 LS** | 提升解质量，增加 RTR 接受率 |
| **不重启** | 保留 Explorer 的积累，避免多样性损失 |

---

## 6. 初始化策略

### 混合初始化

**函数**: `init_population_jit(pop, D, finite_mask, knn_idx, strat_probs, seeds, rcl_r)` (lines 786-816)

**策略组合**:
- 10%: **RCL-NN** (贪婪最近邻 with 随机候选列表) — 高质量种子
- 30%: **Insertion Heuristic** (插入法) — 中等质量
- 60%: **Random + Repair** (随机 + 修复) — 保证多样性

### 为什么不用纯贪婪?

纯贪婪初始化 (如最近邻) 会导致种群起始点过于集中，降低多样性。混合策略确保种群覆盖搜索空间的不同区域。

---

## 7. 停滞检测与重启

### 停滞检测

如果连续 `stagnation_limit` 代没有发现更好的解，触发重启。

**参数** (tour750.csv):
- Exploiter: 80 代
- Explorer: 150 代

### 重启策略

1. 保留当前最优个体
2. 重新生成其余种群
3. 重置停滞计数器

---

## 8. Final Polish

### Double Bridge + Deep 2-Opt

**时机**: 在时间耗尽前的最后阶段。

**函数**: `_double_bridge_jit(tour)` (lines 743-783)

**流程**:
1. 取当前最优解
2. 循环 30 次:
   a. Double Bridge 扰动 (4-Opt 变体，打破局部结构)
   b. 500 步深度 2-Opt 优化
   c. 如果比之前更好，保留

**为什么需要 Double Bridge?**

2-Opt/Or-Opt 只能做"局部改进"，无法跨越某些结构障碍。Double Bridge 通过切断并重组路径的 4 个位置，产生 2-Opt 无法达到的全新结构。

---

## 超参数配置

### 问题规模自适应 (反比策略)

| 问题 | 种群大小 | 原因 |
|------|----------|------|
| tour50 | 10000 | 小问题计算快，用大种群保证多样性 |
| tour250 | 1000 | 平衡 |
| tour500 | 300 | 过渡区 |
| tour750 | 200 | 大问题计算慢，用小种群换代数 |
| tour1000 | 100 | 极简种群，专注 Memetic |

---

## 性能演进记录

| 版本 | tour750 成绩 | 关键改动 |
|------|-------------|----------|
| 基线 (ERX + 随机 2-Opt) | ~130000 | - |
| + P0 (非对称检测 + Or-Opt) | ~130000 | 修复 Delta 计算错误 |
| + P3 (精英优先 LS) | ~130000 | 保留多样性 |
| + P1 (KNN 候选列表 Or-Opt) | ~129451 | LS 效率提升 10x |
| + P2 (OX 交叉) | **~119208** | 保留子路径结构 |

---

## 依赖项

- **NumPy**: 数值计算
- **Numba**: JIT 编译加速热点函数
- **multiprocessing**: 岛屿模型并行
- **Reporter**: 课程提供的结果上报模块

---

## 运行方式

```bash
# 单次运行 (双岛屿模型)
python run_island_model.py

# 修改目标文件
# 编辑 run_island_model.py 中的 TARGET_CSV 变量
```

---

## 宏观分析：Memetic Algorithm 的核心权衡

在固定 5 分钟时间约束下，存在一个**不可能三角**：

```
         ┌─────────────────┐
         │   种群多样性    │
         │  (Population)   │
         └────────┬────────┘
                  │
        ┌─────────┴─────────┐
        ▼                   ▼
┌───────────────┐   ┌───────────────┐
│   代数深度     │   │  局部搜索质量  │
│ (Generations) │   │ (LS Quality) │
└───────────────┘   └───────────────┘
```

**核心洞察**：
- **种群大 → 代数少** (每代需要评估更多个体)
- **局部搜索强 → 代数少** (每个个体优化时间长)
- **代数多 → 需要牺牲种群或 LS**

不同问题规模需要不同的平衡点。

---

## 诊断结果分析 (2024-12-16 实测)

### tour500.csv (500 城市)

| 指标 | 诊断值 | 评估 |
|------|--------|------|
| **最佳成绩** | 100897 | ✅ 接近 HPC 最佳 99562 |
| **代数/5min** | ~2800 (Exploiter) | ✅ 充足 |
| **Repulsion 次数** | 🔴 **~25 次** | ❌ 过于频繁 |
| **多样性** | Explorer 熵 < Exploiter | ❌ 反常 |

**问题诊断**：

1. **Repulsion 阈值过于宽松**
   - 当前: `n × 5% = 25 边`
   - 只要两岛解差 25 条边就触发重启
   - 25 条边对 500 城市问题是**极小差异**

2. **Explorer 被频繁打断**
   - 几乎每 50 代都触发 Repulsion
   - Explorer 无法持续探索，反而多样性更低

**结论**: tour500 的瓶颈不是代数，而是 **Repulsion 机制过度干扰**。

---

### tour750.csv (750 城市)

| 指标 | 诊断值 | 评估 |
|------|--------|------|
| **最佳成绩** | 123624 | ⚠️ 距 HPC 最佳 116363 差 7000+ |
| **代数/5min** | ~400 (Exploiter) | 🔴 严重不足 |
| **Repulsion 次数** | ~3 次 | ✅ 正常 |
| **Explorer 数据** | ~230 代后截断 | ⚠️ 可能提前结束 |

**问题诊断**：

1. **每代计算量过大**
   - λ=150, n=750, 每代需评估 150 个个体
   - 每个个体的 Or-Opt 需遍历 750×32 个候选
   - 导致 5 分钟只能跑 400 代（vs tour500 的 2800 代）

2. **搜索深度不足**
   - 400 代难以充分优化 750 城市问题
   - 收敛曲线在结束时仍有下降趋势

**结论**: tour750 的瓶颈是 **代数不足**，需要减少每代开销。

---

### tour1000.csv (1000 城市)

| 指标 | 诊断值 | 评估 |
|------|--------|------|
| **最佳成绩** | 69224 | ⚠️ 距 HPC 最佳 63848 差 5000+ |
| **代数/5min** | ~460 | 🟡 勉强够用 |
| **Repulsion 次数** | ✅ **1 次** | ✅ 非常健康 |
| **两岛协作** | Exploiter 领先，Explorer 追赶 | ✅ 正常 |

**问题诊断**：

1. **相对健康的运行模式**
   - Repulsion 很少，两岛可以独立探索
   - 多样性曲线平滑下降

2. **仍有优化空间**
   - 每代 RTR 接受率 < 3，说明选择压力高
   - 可能需要调整 RTR 窗口大小

**结论**: tour1000 运行模式最健康，瓶颈在于 **搜索空间巨大**。

---

## 问题规模与策略对照表

| 问题 | 核心瓶颈 | 推荐策略 | 当前配置 |
|------|----------|----------|----------|
| tour50 | 无 | 暴力搜索 | λ=5000 ✅ |
| tour250 | 无 | 平衡策略 | λ=500 ✅ |
| **tour500** | Repulsion 过频 | 降低阈值到 2% | λ=300 ⚠️ |
| **tour750** | 代数不足 | 减小 λ 或简化 LS | λ=150 ⚠️ |
| **tour1000** | 搜索空间大 | 增加 LS 强度 | λ=100 ✅ |

---

## 待改进问题 (按优先级重排)

### 🔴 高优先级

1. **降低 Repulsion 阈值**
   - 当前: `n × 5%`
   - 建议: `n × 2%` 或 `n × 3%`
   - 原因: tour500 中 25 次 Repulsion 严重干扰 Explorer

2. **优化 tour750 的每代开销**
   - 方案 A: 减小 λ (从 150 降到 100)
   - 方案 B: 减少 Or-Opt 迭代次数 (从 30 降到 15)
   - 方案 C: 只对 top 10% 做 LS (当前是 20%)

### 🟡 中优先级

3. **Final Polish 改用 Or-Opt**
   - 当前: Double Bridge + 2-Opt (对非对称 TSP 无效)
   - 建议: Double Bridge + Candidate-Or-Opt

4. **RTR 窗口动态调整**
   - 当前: 固定 W=20
   - 建议: 大问题用更大窗口 (W=30-50)

### 🟢 低优先级

5. **P4: Negative Assortative Mating** — 从源头注入多样性
6. **P5: Don't Look Bits** — 加速后期 LS

---

## HPC 搜索最佳配置 (2024-12-16)

| 问题 | λ | exploit_mut | explore_mut | exploit_ls | explore_ls | 最佳成绩 |
|------|---|-------------|-------------|------------|------------|----------|
| tour500 | 300 | 0.4 | 0.6 | 40 | 15 | **99562** |
| tour750 | 150 | 0.4 | 0.8 | 30 | 10 | **116363** |
| tour1000 | 100 | 0.2 | 0.6 | 30 | 15 | **63848** |

---

## 关键经验总结

1. **Repulsion 是双刃剑**
   - 太频繁 → 干扰 Explorer 探索
   - 太稀少 → 两岛收敛到同一解

2. **代数 vs 质量的权衡**
   - 大问题 (750+): 优先保证代数，简化每代操作
   - 小问题 (500-): 代数充足，专注解的质量

3. **非对称 TSP 的陷阱**
   - 2-Opt Delta 计算在非对称问题上**完全错误**
   - 必须使用 Or-Opt 或完整重计算

